Ex.No.1 Implement Feige-Fiat-Shamir identification protocol

import random

# Key Generation
p = 17
q = 23
n = p * q
s = 5                     # secret key
v = pow(s, 2, n)          # public key

print("Public Key (v,n) =", v, n)
print("Secret key s =", s)

# Zero Knowledge Authentication (5 rounds)
for i in range(5):
    print("\nRound", i+1)

    r = random.randint(1, n-1)      # random commitment
    x = pow(r, 2, n)
    print("Prover -> x:", x)

    e = random.randint(0, 1)        # verifier challenge
    print("Verifier -> e:", e)

    if e == 0:
        y = r % n
    else:
        y = (r * s) % n

    print("Prover -> y:", y)

    # verification
    if e == 0:
        check = pow(y,2,n) == x
    else:
        check = pow(y,2,n) == (x*v) % n

    print("Verifier result:", "PASS" if check else "FAIL")

Exp. No.: 02 Implement GQ identification protocol.


import random
from sympy import mod_inverse

# Key Generation
p,q = 17,23
n = p*q
e = 3
x = 5                    # secret key
y = mod_inverse(pow(x,e,n), n)   # public key

print("Public Key =", y,n,e)
print("Secret x =", x)

# ZKP Authentication
for i in range(5):
    print("\nRound", i+1)

    r = random.randint(2, n-1)
    z = pow(r,e,n)               # prover sends this
    print("z =",z)

    c = random.randint(0,1)      # challenge from verifier
    print("c =",c)

    s = (r * pow(x,c,n)) % n     # prover reply
    print("s =",s)

    # verification
    valid = pow(s,e,n) == (z * pow(y,c,n)) % n
    print("Result:", "PASS" if valid else "FAIL")


Exp. No.: 03 Implement Schnorr identification protocol


import random

# Parameters
p = 467
q = 233
g = 2

# Key Generation
x = random.randint(1, q-1)   # private key
y = pow(g, x, p)             # public key
print("Public y =", y, "\nPrivate x =", x)

# ZKP Authentication
for i in range(3):
    print("\nRound", i+1)

    r = random.randint(1, q-1)
    t = pow(g, r, p)          # prover sends t
    print("t =", t)

    c = random.randint(1, q-1) # challenge
    print("c =", c)

    s = (r + c*x) % q         # prover reply
    print("s =", s)

    # Verification
    result = pow(g,s,p) == (t * pow(y,c,p)) % p
    print("Result:", "PASS" if result else "FAIL")


Exp. No.: 04 Implement Rabin one-time signature scheme


from hashlib import sha256
from sympy import mod_inverse

# Square root mod n (using CRT)
def sqrt_mod(h,p,q):
    r1 = pow(h,(p+1)//4,p)
    r2 = pow(h,(q+1)//4,q)
    qinv = mod_inverse(q,p)
    return (r2 + q*((qinv*(r1-r2))%p)) % (p*q)

# Key Generation
p,q = 7,11
n = p*q
print("Public n =",n)
print("Private p,q =",p,q)

# Signing
msg = "9"
h = int(sha256(msg.encode()).hexdigest(),16)%n
s = sqrt_mod(h,p,q)
print("\nMessage:",msg)
print("Hash h =",h)
print("Signature s =",s)

# Verification
print("Verify:", "PASS" if pow(s,2,n)==h else "FAIL")


Exp. No.: 05 Implement Merkle one-time signature scheme

import os, hashlib

def H(x): return hashlib.sha256(x).digest()

# generate private / public
private_key = [os.urandom(32) for _ in range(256)]
public_key  = [H(k) for k in private_key]     # only ONE hash here

def sign(msg, priv):
    mh = H(msg)
    sig=[]
    for i in range(256):
        bit=(mh[i//8]>>(7-(i%8)))&1
        sig.append(priv[i] if bit==0 else H(priv[i]))
    return sig

def verify(msg, sig, pub):
    mh=H(msg)
    for i in range(256):
        bit=(mh[i//8]>>(7-(i%8)))&1
        if bit==0:
            if H(sig[i])!=pub[i]: return False
        else:
            if sig[i]!=pub[i]: return False
    return True

# test
message=b"Hello, Merkle!"
signature=sign(message,private_key)
result=verify(message,signature,public_key)

print(f"Message: {message.decode()}")
print("Signature Verified:", "PASS" if result else "FAIL")


Exp. No.: 06 Implement Authentication trees and onetime signatures

import os, hashlib

H = lambda x: hashlib.sha256(x).digest()

# create OTS keys
pks=[]
for _ in range(4):
    sk=os.urandom(32)
    pks.append(H(sk))

# build merkle tree
tree=[pks]
while len(tree[-1])>1:
    layer=[]
    l=tree[-1]
    for i in range(0,len(l),2):
        a=l[i]
        b=l[i+1] if i+1<len(l) else a
        layer.append(H(a+b))
    tree.append(layer)

root=tree[-1][0]
print("Merkle Root:",root.hex())

# verify one leaf
index=2
def auth_path(tree,i):
    p=[]
    for lvl in tree[:-1]:
        sib=i^1
        p.append(lvl[sib] if sib<len(lvl) else lvl[i])
        i//=2
    return p

path=auth_path(tree,index)
h=pks[index]

# verify
for s in path:
    h=H(h+s) if index%2==0 else H(s+h)
    index//=2

print("Merkle path verification:","PASS" if h==root else "FAIL")


Exp. No.: 07 Implement GMR one-time signature scheme

import random
from hashlib import sha256

# square mod n (one-way)
square_mod = lambda x,n: pow(x,2,n)

# Generate keys
def generate_keys(k=8):
    p,q=11,19
    n=p*q
    s=[random.randint(2,n-1) for _ in range(2*k)]
    v=[square_mod(x,n) for x in s]
    return s,v,n

# Sign message
def sign(msg,s_list,k=8):
    digest = sha256(msg.encode()).digest()
    bits = bin(int.from_bytes(digest,'big'))[2:].zfill(k)[-k:]
    sig = [s_list[2*i] if b=='0' else s_list[2*i+1] for i,b in enumerate(bits)]
    return sig,bits

# Verify signature
def verify(sig,bits,v_list,n):
    for i,b in enumerate(bits):
        expected = v_list[2*i] if b=='0' else v_list[2*i+1]
        if square_mod(sig[i],n)!=expected: return False
    return True

# Demo
s_list,v_list,n = generate_keys()
message="GMR demo"
signature,bits = sign(message,s_list)
result = verify(signature,bits,v_list,n)

print("Message:", message)
print("Hash bits (last 8):", bits)
print("Signature Verified:", "PASS" if result else "FAIL")



ðŸ’¡ Summary Table for Quick Revision
Exp No. Scheme / Protocol	    Type	                   Main Idea	                                 Use / Purpose
1	Feige-Fiat-Shamir	          Zero Knowledge	         Identity proof using modular squares	       Authentication
2	Guillou-Quisquater	        Zero Knowledge (RSA)	   RSA-style identity verification	           Authentication
3	Schnorr	                    Zero Knowledge	         Fast ID scheme using group arithmetic	     Authentication
4	Rabin	                      Signature	               Hash = square of signature	                 Message signing
5	Merkle OTS	                Hash-based Signature	   One-time signature using hash	             Post-quantum secure signing
6	Authentication Tree	        Merkle Tree	             Verify OTS using tree root	                 Scalable signing
7	GMR	                        One-time Signature	     Square-based bitwise signing	Secure         one-time authentication
